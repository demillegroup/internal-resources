<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #4CAF50;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #4CAF50;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #76B852;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Protected Page</p>
            <p></p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="DECRYPT"
            />
          </form>
        </div>
      </div>
    </div>

    <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f140c7f402755d714e656f32f28e9d6ada698038707f1b81b54477bdf0e7510dfc5a09d2bc7d0edbf058a5f56179ba0abf5651cd435edea4e0edaffadf249ca18f5fa34dc4b66667e7e21504cd76cba9dba2e685405b90bfeb584a82d1302c4b53542c81ce01a688cf58465c36aacb5d92b46d64fe3a1b743f59a06ed88ed1d3459cf290e33fcfe0ed33ea5a27bb6975a6f1db83ec5356b5c2ec4ed5a284687377cf7a6324e9630dd0e794efeffaf5431d3d4ff08e97e22b568f264cdf053ab06b54b655910cc22f326d182199e0eb810cd41c58ad37b0f95cbf2c39d3856af75c30ae92fcba80ba79abc9b7b228ee84aacd6da527c679addd15776da72659a620bd564a4260ffbacbc5b93780041fffeff87aa07084e20578fc66dff6aa196cb4766e062eb0a191cf97dcc8f861a3afe65473ab2bf19937f32cf19c963d17bc6ca1c816be329377e9b23257842c8a29b0bb09af756d1899b6c714ecbd232f2080431c87c09e0d23c99a68a488f6b6a309ba407ddf5c6baf8b0337eb9120b4a73f83ca5312a41b7c422c4aea79e71c56cc9a6dc1de067d7a54bec0fc2c1fc0b6da86969f23963b781375a64d2ca71a68243a52d2fd4fae38da1a3d35113c76acb63bdfd16ec158aabf9e131da95fe8933adb7d275462d9c4036035cbc171df1ba694acb67c7bdd66efa2abaaf565d97fc7b671b95dff65bed5419a1c1cf2d73ff5316a55772b075caebdc9c0f5e772f7101201ebaa6dc46a7fada2b7a5e4a2b860e8a472828c08ee2bdaf60f76c9a36bf61aa72170c3356731e77e994bec6fc52db199129e6ca4e14b49c537df6935220d6b541e601b170fafc896fe7248ef2863dc7065bc6e965a2f6ca8950bf31a77f63449bad5f182f3e5db5b3f641bbb3b48e85d66743e7a0aab8e805b10a187a7a6e9f1791b9c0bb2596da52657cec1f82ffa2080ae30becbb940e3bf170cfec55ef7c6184d6b6ced52cbec0b546aadd3e3a4959222f3c5bc56af9ab545d3191985fbc86a6ec1fab37af38ab7fecee07c2961e7255b7d7f7492209130436b4a703ace13ca08dd939ed20332927c95d10c9a995b563d77fdfbe59414ccaa8fde7b24f945f1e335352f8860b857fd4932eded7d9a1d43dd433a783b8d4fa1bc0129e5c14d20f2216ae4ab3cc9e7c210cd2a304745c49b4f31e1a23c1263a606d2fe908478cd1945efdef49fec4a35063a6e7670bdcdf1c3b4e0e29a6f134a504bcb454cea076dbc7d0b175e384cac9d79079e771a624be49189ba789a57c9733c40703ff9dc0a430c81dffae5bd01404bbda9b80d362638541ab79e9d91618115d63c4c629883d32a4bb04a8a8d97a118b3e747e400a5735877c2c1409f8b946742cafa2b7ea3413a48d9a4fd6935c5fb94a3f01bbeb97a289c04d3e38e2a475709a642a17b696c23eb9fe25f9060f4590a0c45c3106c0601bac743405539dd117358158af5829fc47e07e1404db29490045b2f3d61b7ad3cf88e52df0eea528400dd3f49fa53080983c4e54e959a10b3fc8b30a824ed2ad4b674503e98a93d16adc95d4d290e1f2fec8543c1a1282e30e268bf8ee5aa38ac909ed2084d32a05277ea92dbcd9bbd6b5824efb6b1d80185e20ff6c1ad9db8243bb0b5a091fed30e8dfdd8257986a8c9f983a54b5556d516b446f0babc87f2f883b257ad19952795a9c1b9e1c5a5c70fa3a47c94b35bcedf5fcaf7f1f66be6374c1aa80dddf000f9560ad70b4fb14b09773eb14a9a581243fda6d6ebc0afe35e96b9e1403a1721cbc3f8de594b4823cc4e3904f26784bc952485808108f897bbd53bb5b0a982891890072f591d2c071c0da2dbca1d8e367d38de4bfc4a96ca5f6882066920c4d419e253453b25562d1c2cdcac5817838955904ea0db06546e689f9754076be64ec6793f8989635fdc34023eb7e70869b98201c12b09bc52ad8202f780d4c8406f30bcffc91a3b8f6c613848d66a392cc9439a37ca3f0afdf1fc2b842af9e40fba040016e2084bf253ba24fb62aa1d4d8ec649b530afe67d4d92c22d914abf9ae3e9f80088fcf4362ef19d147e33e33d95d03f6ccee238977ae3e2f2a6b9b74fd156771bc3d0af857f14eb8102578f8cefde36da37961f8838367ae9bffbb4b23bfcf016b15ca34f1f70d83e63c80cf33188ac162d057e35b54b4c365621e312d85aacb2a108e58a8cb91e73ca340040b52fb32da5163d23567c583b3e24fe926d59e367fe7c5a3d85528872d58055e965a5fd1918d110e8378b2ea8e96f269fd9b5aa64def7ba66dba9ec0059622b24afbf613e4125d35d38ba286a06865e4e97003a089594200572bf8f8c68365fd15c7aae13058065ab274280d7b037b8f8a0f2d32875582e3a5e9aeb0507eb381017f1d4b5c3868d0b51d9f680fc89803c3e9cec88007ab107fa00280cf69e556a5474fcea745e9dd1dd75ca673c72baa62a84c86c8421ab8e8cd8dad6c0a7ab7524044da92a53ac39f71dab7560c9d7c54df0619617b2bd97e57c562b6a3f2f2bba74b65ed68db2b2cdde7782c674d35b985e7d736ddb5b2ead7e34c333a45b4c4a35332b42719df2e1b0d6407005edc9fb7e78e7ffeecf35bc01e6e9e8ddc390aa910afb8ec5f850eca003929176eeea1434b2e2e965a4431d4d200f88f7219b9372f22d75e42651838d3bddc34855a5efba177f652336e7d651dad0640e481e9c023b73389be4bbd45c3c1a3746c16de504e06775773f914e40d55bb64b5b866fec967a5238d6df499d067987b1007dc5fa2b7e2fcb3d45934169c7950870ded1d1106ef8e892189e79ef5e2e627b57a4fd6f17ee0eb1fb5e504415098497e48beb075ed46517ddc623d0f0ff088a5a1f25dd61e7dad15be79223edc27f999535077f9276b2f88f8e1bef679c9b16619e7a3fb43d16b288c582e621f8b0f27866c936a938e12ffaf234606ce39cb202520d10804905578fd7e99fe1a26dff50a140bb4cab15d8ad5d3f08d408784440a6d98903a21b67cba7b24da0a9e5b5f14e9861bb95adccf7474ecfbc8cf25ca52eb82cd66625d140eb1cd41d278ae51965f067b140e0c51b4df9fa7ad6e2b60f16830060db44162a6c3a93b63629c8a16778eb73176482ed7e54ae344ef35b8b2de5fce17446557506c85351c564b32fee87fd68e4b7c326f618b4a7b14856281c6d785cd312497ca4daa0c8b558e40532e07bee10fef923f267a809e613224675660c741c1fa35e4f4512446aa9154216c000d8438a83ad83d2ca6dcc667bb4c58495c1d034c8e51f09bdec1d7b73b1ce8ffdc6485d36bb3dccd6b19f9956bcc6e89acc7843173c104c0ddc8c3f583d2344b91e01bbb65b06910f1f77c43cb13a52b23e0d4a64ec9fbc77dcd05b5380046de1892eb59a91bc072b59deb25f222e6318d41f0e1a1e68616c84380cd288a981a10e18b224f37fc1a086768291fd6674006e7e78f5b72402ecf2e365ce420fbb91b07798fb11f92a1777a69c6d68bd2b0f37cf22a0a59f50e3f592703dcd8fc41f440bed1bfc960b6bab556f12a354415bd17df77e7f261563710708a7d05f1d4ffa71c3650d831e4c186a17cab4a1914380b765c848102f237db0000df07c5a1902fbee29bbf789e8929056318e76aaaa4ce9e2fb9136978fbaf6edaf6c29b78c668ad1eb73c6bf3c8b5d0b6d23a14fc0f177b479afb49f6701a3cedc60f7a506285d733dbb62c9f533d9cfac5faf729f69fd4761371c11e4714d6a6e273c9820938a583f458dcfd28adb6eff8eacd1ffd1343879f5a306a52cdad773daca2565a3d163cf237f71104b0d0dcabdba798d552eb8e5b99ffba398f1a929ebcd83948e03b1674b8514115a252891322d7ee13228e866a4c97cbe1138204c78fb26b7b692167a560e3d4535eb4e5d0f68f48605651aab82baba9fee8a521013fc9d59904afe06ec370116373e22729744ba72bbfddf59ac4b28282f282d0ce562c4eac3c1c6066965a6af5c40a75d9bebbff75e92cebeddf298defd31c4decfb08a033907d77097ebe701bfae6e3975decb1e071cfc225d9be0205be787fa8f5cab922942b1539a9d175faef332542442cd070b63186d01f9ca10204a535737f0f6fdf31e1d498ae8b36ec8e8724f0aedc23f8551e9557af2e607f9d3c575f33ef3a2e61f8a5e2b7a7bb13aaa06d6b5fcda13b7ebba427651bf69fa92ab9d214027294ffa2315e6c157b2656c066add62b0e64767b9d3d77f2fea6224f95eb584d366a477d4934848bcba8053a8f4609339eae9dedf55a53723f194f1817c8ed75dcd8a056e1d19ea183afd164a6c6d0cc15d6e5ead4b4da7aba66c56d15518a0c46242bef9304e6d2387ca6794ca914e6e2ec52955ed361bd8fec90a01585eff020ea8a7b7c91550c0563cd00afe14b04fe913856039bf68bc3f0c15229a866c5961390704dbe19205e5754914a6dee81cb33ea325c533ae8d0125d3645f2331ce482d1f548ae84b0e0889fb0528a7c1c2b19716ec0575ce25780b1594cb852ac20e55311b9c5bf76060e5fc6e17c62579a9845c9b6b5fd311db70bccbaccd669daaf16daabe2489385035cff78633aab7865d88a1b54e831fb659088c75f314dd8d9d1004366831d56d5bdb27efe8624bddccc73f0132cfb6e90cc97907f081419b124947891bac5d3b02ea6323df8c15b27bed8c1bdb4dbb81776d55b689715399c6b92587c9aaab5cebf820f2170553766c6c616846138fb2a5ca911ebfcb40463a324afde6c6f6ac0a6f1107adb1834e319b21516107b41d478d31deaa614ad807ed9cf40ad2eeef5e217c4661499c5a6b9da553851c1117e91b4a8f4031a6e9cf469f3c54665db6b6bd630748c9c704d9b63e84217fdbde101cdf565d812223be2fbaca9209ba1facd950049ef05e2d283e48182f6abce447567d69382767ce85453c103d9dda5be6839fb96e10a6b3c0a0fb72996ecd554eaf10cfe10a0aa4fb51cedb83ec48aa54344be94e6ce93b48a158eea7f62be35df00c177ed45b6947996d382016daa4417cb7fa807a997a957ca3a822e898980790f89c3fbaa85cbd03c7da167b9d7e0d7521098a81a93eb14b9953053b279e75190016f715332887911195a874d7d13603a378adcf0a21f6f36c19ba72489afac1582d815299b8ede5362c77d9a16b265b2947e0d2a987b0cf73e25132a5f157d3ec8733af39b2139a7c9968659c5a158f1f9b0b2a53ff45f8c3456d4f63e337d4c58a7eb735caaf3bb4b9df50e8881a72edf947cc6277663c631d16085cb45cac26c15a41c771ede8b76a6ee27bcce84217bd5d5e1a70da2c961ba8fcb80bde784bc753dc303e9768f984b59f6cc64dbcea83655b79ae31d687ed69920dab2f25cc168c186736c7d30761e643cda9057c967e8c32de7a8958ac8144b60d24746f768df6ed46234e55af44acbc6a82fddd5642e678ec56b76c904abc1d40319cc47f8afefaf0dcbcfc7cbe91192a3455ec4a889a0d2638f005848698799330c34b9e351ccd6c8f610d6118e02702e85572c701dcdbf67d9ba989c47d2cf2d0075f23ee1683b10d621d85ec1e97ee0f4ecdbfdc6ed3301f7371600d4a1428ea2d2a7ecc91130797aa610d8d9e8209ddc08bbead4a4bb40df229ad8bbc47a6ca730c76d4937a0d18872c104441e78cfa8cd00607a8daa6d866c8f2d510501cdec146e41b6e9d2acd3aea2f5a535f48379d63d911a93111c6e3cde4b9ce4b9f19a45a31e57826187504af7b5e391a7af42c3d57f70b340bc6cef6749d59ca5fbd82a66d6657711569533e4c1dc8ab2b17481972f729a57386c60c90e8c5e73fcd0b3cc54eff92f1f897698c98b08926f067654725679afd42a9bf0a50ed2cff43246ee1c8350aa1d020a95c67a11c8ccddc60d9b76cdf5b986f1de82ae6baf929d39bc79e9a70263859f1995156b56d06cd1c63a40d5fe9fc5e4fe92e82731f03c9d57cae1d80fd59bfe4f283abf91b61cce32a2f9dfe94882d73e2d17ceb5eb3e77acbca4d65ed0322e513554ad166d69e5c0de6983a3e85","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c2924ceb90110e227207d68fd1c4fdd3"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
