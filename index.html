<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #4CAF50;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #4CAF50;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #76B852;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Protected Page</p>
            <p></p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="DECRYPT"
            />
          </form>
        </div>
      </div>
    </div>

    <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9bc1f0c1806a1942bbc5aeb4095bd5c919646af39f8e9c72b16f029218f8eb8b83ea4186f01673aa678b48b0373fcb85ec80885fb1011ef251a307be3c465397cf44acddf7d9702231d0d551dacf4c0d930eb87796293065b42e4036cb7543a755e9f48dc978a918fb38be7b4045c83333f1fbb8f42da7c721d05dd4d2e2228f032efeedca958ed6f9333f65ca6411c18bf64bd1b6a072c0cdb8f888ba1bcd338cd853d31fd71c9a4b2e3d4897f87d9231fdfc19468603ac717b0b1ef6edc52ae67227cad16381d064daa5d1a4f440e1a570da79c8955c07c85d339f5755eee29acb3f6e804c719010f7cfad6e1bf324663d2605d565e2f1c24d0573d68f79d6f04138d6dbb256d07ccac72ff6bf4fdea22b9c729b9bfff3679f26040ec6a323d77d7a09bd02cab2e0cbcae234aabbb1683dab03395fa3f1575802ff2b90fee2b2b5aba97ba7c9994b759c635c36636dc3e4008a2f91a06e37924322a29799001cddcb0dd5e9ba8d877039b414127169816b7f9d979eb6d0ec596afe1d7dda7c929a943a0874dbccb5b7b7fd8034abd6b7adf7347e4daf9ef6cba2c47b9d60d40016d03837a1fbbeb8da3d742d29dcd2da870fe09805dc2351892e5c2a10f7c7828e48bf9efee491cae7c70ecb32d393e98ad322c4bdadf0bf7290fcb04c1176960b2f66ec0a6ffbb3aa5f7905ab13adeaf4b7c6b580376813884a1be145cf02cee6648d98a5a7216c64eb42a7a1651f0a47ea16fdc6cb5574323f37d464892ed23d3cd1ec2536a98ce024a0e47c0d4f67b4fd5e7ab6b4748b54f9b66a56360bb04c48c3afa2fb251b624e6b6c8f202a490ecda30495e2c9d65f560e4c7b4fc74c9557de2fa04b13f94c44aeaed9048b9c604bd498a2073d66148913cc9e1d18d7900ec51f502c0afc3213633a3faf1243d47350f4599e3c35793ef87f7f9c9e7b7adee6c559541af75464d1ba72295e81f9a8bb28aebb976a8e7db27a2ba98759bac55bf4dc60eba824efc54d68e4b4dc8fca94fc0f8825745086b21f313ff67d12a19342c2a74e757457ffdfb59911f44f4db5ef759f95c3fdc0795acfd60717926155c947a10cadb66be5981ed9813234c5791145aa1db434c6addecb1aa789952eed983d9eb6a56f3a0aa55c51faeb73b97cb6842a6a12e173ea02b1fe799cf8a9c9124d1ebfd72f3b933c666001f6f224f41cd3b03d5330d4004591cff3a69f03c395a7e4f115492c4b0cb8629aff6e1fd796c567badc48e555b002462273a3d40dce5504e767115fd168865036d8ae796065bead8768aa71c3043480ff3c133e54be5837d0d4747fb0b725944152165bd72137dbc4efde37fbb34cd58d5931cc1e7a0d60933ef289f4ecdfb8f5a6659b12f5f54ea61fe2721b1e1562c109f7285ba6a769d90329253369c16cee462305a9ca9cd3b41a258d8d66e513b82314c0073562612301e77381d24453055d99812c768d90ed0d6fcb8c8c242f2d7451a030a6b5deabd42407ea1f0c2938bf6111a2adcdca9292a2109aa96701dabe91f8e8335db5e5828a136dbaf848686824b9c1fbcc7ec2c8983e60de0a50ea48aed044dc9216a1062fc4abe49e9c65ba59b7137a31487ddc56916018d8dcb4f2b60347fd85ea76c92802000340d28e4373f2ddb42be831a1212a29ddaa83335acf22f57cf60c52c37b198e43f272dac68d0d07f9928aa5852cb80031cdf6ceb0c5b4173c89525afb16f6b8885b9c80d5ad7999de34adcbb7986dc6cc1fe9e1d92fd4ae307d3e48a5fdffca25f79c9e996392872495a4e132214467ee739b1b52cc3aac3b640e7dc033423b6af1f48012f446d7fa0a708ebf5f47801380d8f3f23a93fff305e4f168b941acd882ddc37dfe44902c3799129e717991523044a5b8b65ac06a7c5b67168f6447315046c8f628d3cd4c3eec24cadf0d764b860f8c8e762f23ecdaf5fd52c8dc0cc44f036ab633defccd025c8d8cced16edd042f204804aae2216f5dc7736df01eff913b2306bba425e224c396676d5088f49c447b279d71ac8853d194dfdacb7b01a529e3b9cbca9d9a1892e2c060e4a50120235f60bd985bdaaaa0e16186d14adf69c54f7bcb2dccbbe663bd95c131f8e39159d35460e5ecf77fd42902a55fcb332b293180bee7ad38bc71de9373a88acdb049b8f26a11c697a91310640e956d57fef89e1efd61716d41fe6593b8676fa21c860b20c43bb8995e29b26a290dd2e47e389ee2ae968e907e29b1015098437e06da6aec504783b62d94d9018d2a1f5e74ccd1d08c4a7954bb713a1158d5b677fdebc2d4fe32065e9970fdcd52ac7b2fb1064e7dbf09f9e55024aebfcdca2fc775bb08f890240c22ad54c6bd22e7908c0e749c277a1d09bba5201f3a7952bb3c477bca7a2ac0cea5f5cc0084feeaeea29a674542422cba65dad8a11543e5195e446ff3ef81743dfa11600b4d93557a0d25521b5f4f4da8a91defd730cad4028384a951e6f60aeb93af1c047dfbabb457e3afc771512d98c25d37c0e47cdd492ed26ef3bfa0066c15d1a5827a78422e7881bd0f57cf2e75b6d0b2ef532836cb95d1b44d7cf726108c81665fe3f08564bf783e9893ddd5151c040a243bc08242ea02589ee5fa362afef144cf2fe9fc55e003588ca1d16586a585d3bc041e7896ed2712f3898e7d961e1f77f53e9b7117b57f88c931ba50f3745ed32eede751903d7ad19ac1ce2d470388ec5d2d66ee0889a325667959c07eabeefb53799ba2245ab13ed76f3cd3fd35895c6a45258ddee8f931d86b7d5ea2fb05924f280ae711d0d45f3eecb4ac16cd238a489237ee4182cf61e402a2c35e3b17542ec48554e7a1efda9c30f35c0254c8f1a4791fc569e1402b6c2b65937239b556ae0b05e18837f004466dd862f84f7415be17ad3a59b2ec1e515fc12f161d6f994f6323bff6676a6018ac63b4c0f8e70b845c8bb01f1157ceb29b60f0be93d069d0e025098fc6ba25ae1c594083ab0b3b29e3bd0603248f46d1d390dc1afcd741cd6ccaa7c09fd9ce9ce59ce407728a63cb8a6d9340c36bf880185ae19c47dc0d75918b60ce9d2bcc6e2cb7e9b419fd7d4e7500f28e54c501d331f3bd9260a6fff461c8eb53f197716c96048145aacdd40d190a1db86cc2d55b83b9f3660a26aa269bd434c2bdc6d50ffe2f5b4fe4d3ded87bb2b896756686da72641f8be5804711a7ece46453977f37f51ab416c7097bde026ece3add706b172a60cf90d2b89fe9bbef5f9d99e4f1d5244da39e1df83f9044383c9274b372fb8d19a37f3e0b001aa5c7b7f77c5ef5b024181e6eb55d6135cba485943310e1125d94a30efc0d08357ffd06d0e50827897f985869c5319de187c6c8c5f00a49cac353cb0cd8b5f34c551162dbf73527275e686097e385a954146b27450d3076b1733c365335124cea8d8c53ca7666d195ff1b65f9b48877c41e0ada259fa95be4a3d3bdbf6af4317fbfd5a91fd37969a25f3230b2295fd6f8e35f203f96f3b7931a3512e0d1c1ac6e365df712bcf77268e00e5b74e433090c8422557b4e437c2caa81bb2e0d8c5545db98207e3b41943f42991cc6d1232fe49efb45eeac6438fd261350f141b159bb845f56b1ace7a86657bd0798126d3a4e257369d07aa85527c6a32522b17b3815fce42fe65101d2f8cd83b9900bf01fd5b721b1724459c1aa51065397d55a488b346bda16f230f479456f0c8c756552477db8f41fa1ffd99763549ae73d5bdf5f43d20a8f8fd7f9fadaa8ddd6311d0d6cbfed070ed1a3e86c1547461da1a136eb00b46c373beb04f9aed86eb12750a61c4cdef6ddd174e25d0df231a22e8d320ad881eadab4e8420e9206e5d83ff5f5019095c81bc63105dadb5def7ffc5c633200600f6f80665c04589ca011ce8a20c8e1213c2b3c2385d655155aed2b176846c655c8028e2dab74d7176f99692cc78da0250e4ffd4984fa34fc18da2da83f03bd471a0b257f66607f3473d869be6db87b434700e3100b157e53a0c3b19715454eec9f02ac84de3b5c535fdbba532d42a95e21e905a4b981c345799c57aa3347263f7cd0a868dd37a5ae0d2edabd83d3a197fe0c90b4ed24b70585e0b3ce21f05f6800a40bcff81c1e0c20e93d6cfcfea80a735a1270e169d08ebd88fdf99f74f97d827d6e189f10f9d1de501c064a816d77d28cbfade87b294b3827d44d656443d6cce2c255cbf97b7b0222b101df2fc2d54e29a0d4a849f9281bd128c666e36f9dafc2f24aeb322f18fc2337b7bebf67f24d08394973502b455a7abeabece36004281beeffe448772197790baa8515896059b623c2618d9b7f8af62795ad2cb62910cd715298a53add244db5395b95e6bd7a43a8ef94a3e332a8f0fc7d00a423962c1201dc1f850585a7a45cbea387da0a2e5cde3d372244e53d98d0b9037b0d25ad9dfa885046bbfef4ab55313d27d77060ad73d777c752b2f6a3305582672b2904a87629f7bc72adab16d1df153aecc915ea62b17be7650b28675528426cd6ad451e3ca65af0d6aa576e73348f9f3f8922a237c82d81fd136387d53f9377008bb5b0e6041dc4df374f7c36684b67978c932c202324dfee476c25ba106bc81e4e517e2d6e4ace0410ed3bce9443fcd8c55fe2ed85798e75ae88099114ca65a0f741d81041bd7c3fbaca19c96b23ca141b8348a24cea9bff234f5be490c24f67705412bba6c8028af59f0c49d17ef0a33557ce2c7ace11715aef6bda761505b8c631cc40b04a4c5ec3c4f88c66be523acee45aa3fe1898769ba1b42188f7102c09196db789a1acf51b4f44a89a07492704949aaab96f0746bf9c6819e03ed21034cc567bf7a5a7125f94024dabef0b85cef96902674a3483b6e089a47ca9d9de506f4b0025b5f99595a7dd941edfb0ec69fd76bc6122002c32e154c95639aa2b2f69e1fa12041499236c87d373af054b3ebea92cdcb180c9c2e1c045aa5fa822cd63e5735be17240077337dcf955d3d6d03a5c1964aee272fbfe433f3e83b6b24dd8012a73dfb0efd54581fe87eb48470f1d795c759da740083e33454e8011efdb8d08495e62207634de41d03aab02ec5b0a9305da06ddec7afabe21cef7a3b5746dc777f810edfa7e0890936d3fba00fdf75322e538daaf7dd480e77c9b74546e697b1bd48b67560cd8f85102593c2ff6d185ec2f84e5b74e99be87f5d730d4897b6988926197d61207322bcfa769257d6306e16c56b1d7e1c1c488d5fc083af9921fd509d2e2febe9cf2fcab9b33f9b0ba69ba62e014f14ca137ddb6cdb74768cd8a710f4133f27c7febfdc301b1be3f64baed7973d769b42597f2bbe6ab0135a737ddef42ed01b7e82ef254f48d1ac625f2d3a242d1ac03c88a0c36af0a7ece68cdc137f0be158469cfeeee217f132065c7410c185a9206eba0dd2c4081a953e94dfdbe109467885baa0f00a812da73aae20a988a0053f9e0f00ffa5b952d5cd55df0a30452620509d36dfd0be4c7781a8de9cfb71b1891813accb37fb2f5ed58648876f1327d53397dbfbf35ebb8f53f7a5c63e381e5a5d5eb7e3ce1faef932a0464e07d84c59a158006846da357b411cd2e13b6c24895b420d5308db7890e3a40f0073252beca5fb7f638066c56f54e6b16216bd5f8f75b1b35f1c762da69b426ebbfa38d15c7b9cf9f8151f3acd938a698f98fcd7a4ccbc3c282d73d8a25b187141ae1d2beae7889282275c2b542d2c7a7585e681e715791603096fc74f039fe0b1bf92bcb4bc669bad5f4cd2ace472f846db4c2f890cb9cec2d9bd29601861e7f0193cbe41eb44b5e3bb36dfe8ff981d1c6b7c399adad076ce8d1953fef203f5d6b747a7362d945d57c7e0657dcc4324adb2e8821bcfe1e43437e07d3eed8c4a2369efcbac5f4aaefa3ed7a74688ee859a315a4cc95f7f4ed3bb871bf8de92b29e6c25c6d964e5a11533c40c24d5c591e7d8eff9309352064b93cdbe3a2d532e2ca957b4e62ecb1e058455368b32516058f27f9d9885429554c1cf9173690269043aaec29dfb28a47928caf03546ab2fafd5af7a6f1b89212dc57864e79b4b3d767005f8f91b03318eb9f9f70f970565686a969219d208127bde6b3250492dde352e6cba9220fb3d4b9801a1285843b403c69f66f0648083dc3eaa8f8ba6ef148e347834167b14c43bc781ed33c7ec583a1c08cf4f303e69cdb039ad1620601fd3a584d1f04c38fafe0f80967eb52efea3b9549ddc63dfb0d5e88ff55e992e731eac40703f61d9281e173b149f1b3e466fe5c79cb9e8c3973fa68e861272c6ab9e2c4542875f106d608bab0318fb8ca3113a107","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c2924ceb90110e227207d68fd1c4fdd3"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
